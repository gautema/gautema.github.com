<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>How to cope with overnight success - Scaling your web app fast and cheap</title>

		<meta name="description" content="How to cope with overnight success - Scaling your web app fast and cheap">
		<meta name="author" content="Gaute Magnussen">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/moon.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		<style type="text/css">
			body{
				background: #06596f;	
			}

		</style>
		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>How to cope with overnight success </h1>
					<h3>Scaling your web app fast and cheap</h3>
					<h4>Gaute Magnussen - 12.06.2013</h4>
				</section>

				<section>
					<h2>Gaute Magnussen</h2>
					<p>
						Web developer<br/>
						twitter: @gautema<br/>
						github: /gautema<br/>
						web: http://gautema.com<br/>
						email: gaute@gautema.com<br/>
						slides: http://gautema.com/pres/scaling
					</p>
					<aside class="notes">
						This is me! Contact me, and please give me feedback on the talk
					</aside>
				</section>
				<section>
					<h2>Background</h2>
					<p>

					</p>
					<aside class="notes">
						Worked on some large web sites. Got the idea for this talk last november, when two of the systems I was working on started having problems at the same time. Two very different systems, and not the same problems at all. 
						Had a custom CMS, which had about 50 req/s and 1000 users at peak hours. And a new system for taking student math exams. Made as a prototype, and suddenly sold to 150 000 users that would take the exam during a two week period. Required about 1000 write req/s plus added requests to CMS. Currently running on 1 virtual machine with 2 cores and 4 gb ram.
					</aside>
				</section>
				<section>
					<h2>What is a scaleable system?</h2>
					<p>
						Scalability is the ability of a system, network, or process to handle a growing amount of work in a capable manner or its ability to be enlarged to accommodate that growth.
					</p>
					<aside class="notes">
						Not about speed or performance. A scalable system is usually performant, not the other way around.
					</aside>
				</section>
				<section>
					<h2>No silver bullet</h2>
					<p>
						Scaling will always have a cost<br/>
						Speed is a feature, and it requires attention
					</p>
				</section>
				<section>
					<h2>Where to start?</h2>
				</section>
				<section>
					<h2>Measure</h2>
					<ul>
						<li class="fragment">Get a baseline</li>
						<li class="fragment">Monitor user behaviour</li>
						<li class="fragment">Load test</li>
						<li class="fragment">Profile your code</li>
					</ul>
					<aside class="notes">
						google analytics, new relic and more are great for measuring users.
						grinder, blitz.io, vs's load tester. blitz.io is really easy to get started with and cheap.
						ANTS profiler and dotTrace can profile .net code.

						It's important to know where you are before you do anything. 
					</aside>
				</section>
				<section>
					<h2>Avoid premature optimisation <br>and focus on macro level</h2>
					<ul>
						<li class="fragment">Focus on the operations that takes the most accumulated resources</li>
						<li class="fragment">Know your domain and your users. Optimise for actual usage</li>
						<li class="fragment">Know the code and where it hurts. Don't guess!</li>
					</ul>
					<aside class="notes">

					</aside>
				</section>
				<section>
					<h2>Short iterations, fast feedback</h2>
					<ul>
						<li class="fragment">Easy deployment</li>
						<li class="fragment">Good test suite</li>
						<li class="fragment">Find bottleneck, remove, measure, repeat</li>
					</ul>
					<aside class="notes">

					</aside>
				</section>
				<section>
					<h2>Test in production</h2>
					<ul>
						<li class="fragment">Real data is the best data.</li>
						<li class="fragment">Test on a subset if possible</li>
						<li class="fragment">Compare resources usage with baseline</li>
						<li class="fragment">Be ready to roll back</li>
					</ul>
					<aside class="notes">

					</aside>
				</section>
				<section>
					<h2>Scaling with hardware</h2>
					<ul>
						<li class="fragment">Developers are expensive, hardware is cheap (Up to a point)</li>
						<li class="fragment">Needs enabling</li>
					</ul>
					<aside class="notes">
						What you want is to be able to just add another box where to handle more users.
					</aside>
				</section>
				<section>
					<h2>Scaling up or out?</h2>
					<ul>
						<li class="fragment">Exponential vs linear cost growth</li>
						<li class="fragment">License costs makes this more complex</li>
						<li class="fragment">Out is more complex</li>
					</ul>
					<aside class="notes">
						Scaling up is usually good up to a point. Out requires more infrastructure, laod balancing, harder deployment, more servers to maintain. Scaling up requires throwing away your old hardware and buying new. Out will just add to existing. 
					</aside>
				</section>
				<section>
					<h2>Scaling the database</h2>
					<ul>
						<li class="fragment">Scaling out is hard...</li>
						<li class="fragment">Replicated read database</li>
						<li class="fragment">Sharding and clustering</li>
					</ul>
					<aside class="notes">

					</aside>
				</section>				
				<section>
					<h2>Load balancing</h2>
					<ul>
						<li class="fragment">Software vs Hardware</li>
						<li class="fragment">Terminate SSL</li>
						<li class="fragment">Reverse proxy</li>
					</ul>
					<aside class="notes">
						Hardware load balancers are really just software balancer with an expencive price and a warranty. Lot's of good open source balancers available.(Varnish, nginx, HAProxy) Requires some linux/unix knowledge and getting your hands dirty.
					</aside>
				</section>
				<section>
					<h2>Using the cloud</h2>
					<ul>
						<li class="fragment">Works well with traffic bursts</li>
						<li class="fragment">Some resources are hard to provision</li>
						<li class="fragment">May need to port code</li>
						<li class="fragment">More expensive side by side with regular hosting</li>
					</ul>
					<aside class="notes">
						IO is not adjustable. Data stores are decided.
					</aside>
				</section>
				<section>
					<h2>Fixing your code</h2>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Http cache</h2>
					<ul>
						<li class="fragment">Learn HTTP and it's caching mechanisms</li>
						<li class="fragment">Long max-age (1 year)</li>
						<li class="fragment">Change url when the resource changes</li>
						<li class="fragment">Use your load balancer to cache</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>web.config</h2>
					<pre><code data-trim contenteditable>
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <system.webServer>
     <modules runAllManagedModulesForAllRequests="true"></modules>
     <staticContent>	
       <clientCache cacheControlMode="UseMaxAge" 
        cacheControlMaxAge="365.00:00:00">
      </clientCache>
    </staticContent>
  </system.webServer>
</configuration>
					</code></pre>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Make content static</h2>
					<ul>
						<li class="fragment">Split the dynamic and static part of the page</li>
						<li class="fragment">Merge with JS or ESI</li>
						<li class="fragment">Cache with reverse proxy or save it as a file</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>CDN</h2>
					<ul>
						<li class="fragment">Don't host your static resources on your expensive app server</li>
					</ul>
					<aside class="notes">
						Good for user experience as well. 
					</aside>
				</section>
				<section>
					<h2>Bundle requests</h2>
					<ul>
						<li class="fragment">Minimize bundle and version js</li>
						<li class="fragment">Use css sprites</li>
						<li class="fragment">Bundle dynamic queries</li>
						<li class="fragment">Easier on the client and the server</li>
						<li class="fragment">Versioning makes caching easier</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Internal cache</h2>
					<ul>
						<li class="fragment">.NET 4.0 brought MemoryCache</li>
						<li class="fragment">Distributed caching (Memchached and redis)</li>
						<li class="fragment">Layer 7 load balancing</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Memorycache</h2>
					<pre><code data-trim contenteditable class="cs">

var cache = MemoryCache.Default;
var policyFactory = () => new CacheItemPolicy{SlidingExpiration = new TimeSpan(0, 0, 15, 0)};

var person = new Person("Gaute", "Magnussen");

cache.Add(person.Id, person, policyFactory.Invoke());

var cached = cache.Contains(person.Id);

var person2 = cache.Get(person.Id);

cache.Remove(person.Id);

					</code></pre>
					<aside class="notes">
						A lot of other features. Will make sure your server don't collapse because of limits.
					</aside>
				</section>
				<section>
					<h2>Choosing databases</h2>
					<ul>
						<li class="fragment">Different databases have differnet sweet spots</li>
						<li class="fragment">Mix and match in the same application</li>
						<li class="fragment">Choose database based on usage, not old habits</li>
					</ul>
					<aside class="notes">
						Use open source and unix. Search with lucene, solr or elastic search. 
					</aside>
				</section>
				<section>
					<h2>Understand your databases</h2>
					<ul>
						<li class="fragment">Don't hide all the database features <br>behind a generic repository</li>
						<li class="fragment">Batch data</li>
						<li class="fragment">Use your database's strengths <br>and be aware of it's weaknesses</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Save your data based on usage</h2>
					<ul>
						<li class="fragment">In read heavy use cases, make it cheap to read</li>
						<li class="fragment">In write heavy use cases, make it cheap to write</li>
						<li class="fragment">Mix and match architectures in your application</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Batch your network queries</h2>
					<ul>
						<li class="fragment">Don't pretend memory calls and network calls are the same</li>
						<li class="fragment">Separate request based on caching</li>
						<li class="fragment">Leverage HTTP cache inside your application aswell.<br/> .NET default behaviour is bypassing cache</li>
					</ul>
					<aside class="notes">
						Remember .NET uses IE's caching, so upgrade IE for better caching.
					</aside>
				</section>
				<section>
					<h2>Put state on the client</h2>
					<ul>
						<li class="fragment">Avoid sticky sessions</li>
						<li class="fragment">No memory used per user</li>
					</ul>
					<aside class="notes">
						Server sessions become a big problem when theres enough users. Even a small memory footprint will give problems when theres many users.
					</aside>
				</section>
				<section>
					<h2>Do slow work in the background</h2>
					<ul>
						<li class="fragment">Not all processes have the same priority</li>
						<li class="fragment">Synchronicity can be faked in the UI layer</li>
						<li class="fragment">Handles sudden bursts in traffic better</li>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Reject features</h2>
					<ul>
						<li class="fragment">Avoid cross cutting features if you can</li>
					</ul>
					<aside class="notes">
						Security on all pages. Differencieted views.
					</aside>
				</section>
				<section>
					<h2>Conclusion</h2>
					<ul>
						<li class="fragment">Measure</li>
						<li class="fragment">Small iterations</li>
						<li class="fragment">Don't stop thinking about speed</li>
						<li class="fragment">Embrace open source</li>

					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>More?</h2>
					<p>
						The Issuu Ecosystem - a real life perspective on web-scale infrastructure <br/> Jesper Holm Olsen and Martin Koch - 13 June 2013 11:40<br/><br/>
						Real World Polyglot Persistence <br/>Jimmy Bogard - 13 June 2013 09:00<br/><br/>
						Telephones and postcards: our brave new world of messaging <br/> Jimmy Bogard - 13 June 2013 11:40<br/><br/>
						Advanced HTTP Caching and patterns for Ninja Unicorns <br/> Sebastien Lambla - 13 June 2013 15:00<br/><br/>
						SQL Server's Last Breath <br/> Rob Sullivan - 13 June 2013 17:40
					</p>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Questions?</h2>
					<p>
						twitter: @gautema<br/>
						github: /gautema<br/>
						web: http://gautema.com<br/>
						email: gaute@gautema.com<br/>
						slides: http://gautema.com/pres/scaling
					</p>
					<aside class="notes">
					</aside>
				</section>
			</div>
		</div>
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>
		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				width: 1200,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: 'fade', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
		</script>
	</body>
</html>
