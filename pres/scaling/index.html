<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>How to cope with overnight success - Scaling your web app fast and cheap</title>

		<meta name="description" content="How to cope with overnight success - Scaling your web app fast and cheap">
		<meta name="author" content="Gaute Magnussen">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/moon.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>How to cope with overnight success </h1>
					<h3>Scaling your web app fast and cheap</h3>
				</section>

				<section>
					<h2>Gaute Magnussen</h2>
					<p>
						Web developer<br/>
						twitter: @gautema<br/>
						github: /gautema<br/>
						web: http://gautema.com<br/>
						email: gaute@gautema.com
					</p>

					<aside class="notes">
						This is me!
					</aside>
				</section>
				<section>
					<h2>No silver bullet</h2>
					<p>
						Scaling will allways have a cost.<br/>
						Speed is a feature, and it requires attention.
					</p>
				</section>
				<section>
					<h2>Where to start?</h2>
				</section>
				<section>
					<h2>Measure</h2>
					<ul>
						<li class="fragment">Get a baseline.</li>
						<li class="fragment">Monitor user behaviour.</li>
						<li class="fragment">Load test</li>
						<li class="fragment">Profile your code</li>
					</ul>
					<aside class="notes">
						google analytics, new relic and more are great for measuring users.
						grinder, blitz.io, vs's load tester. blitz.io is really easy to get started with and cheap.
						ANTS profiler and dotTrace can profile .net code
					</aside>
				</section>
				<section>
					<h2>Avoid premature optimisation and focus on macro level</h2>
					<ul>
						<li class="fragment">Focus on the operations that takes the most accumulated resources.</li>
						<li class="fragment">Know your domain and your users. Optimise for actual usage.</li>
						<li class="fragment">Know the code and where it hurts. Don't guess!</li>
					</ul>
					<aside class="notes">

					</aside>
				</section>
				<section>
					<h2>Short iterations, fast feedback</h2>
					<ul>
						<li class="fragment">Easy deployment.</li>
						<li class="fragment">Good test suite.</li>
						<li class="fragment">Find bottleneck, remove, repeat until done</li>
					</ul>
					<aside class="notes">

					</aside>
				</section>
				<section>
					<h2>Test in production</h2>
					<ul>
						<li class="fragment">Real data is the best data.</li>
						<li class="fragment">Test on a subset if possible.</li>
						<li class="fragment">Compare resources usage with baseline.</li>
						<li class="fragment">Be ready to roll back</li>
					</ul>
					<aside class="notes">

					</aside>
				</section>
				<section>
					<h2>Scaling with hardware</h2>
					<ul>
						<li>Developers are expencive, hardware is relative cheap</li>
					</ul>
				</section>
				<section>
					<h2>Scaling up or out?</h2>
					<ul>
						<li>Exponential vs linear growth</li>
						<li>License costs makes this more complex</li>
						<li>Out is more complex</li>
					</ul>
					<aside class="notes">
						Scaling up is usually good up to a point. Out requires more infrastructure, laod balancing, harder deployment, more servers to maintain. Scaling up requires throwing away your old hardware and buying new. Out will just add to existing. 
					</aside>
				</section>				
				<section>
					<h2>Load balancing</h2>
					<ul>
						<li>Software vs Hardware</li>
						<li>Terminate SSL</li>
						<li>Reverse proxy</li>
					</ul>
					<aside class="notes">
						Hardware load balancers are really just software balancer with an expencive price and a warranty. Lot's of good open source balancers available. Requires some linux/unix knowledge and getting your hands dirty.
					</aside>
				</section>
				<section>
					<h2>Using the cloud</h2>
					<ul>
						<li>Works well with traffic bursts</li>
						<li>Some resources are hard to provision</li>
						<li>Hard to port</li>
						<li>A lot of available features</li>
						<li>Less maintence</li>
					</ul>
					<aside class="notes">
						IO is not adjustable. Data stores are decided.
					</aside>
				</section>
				<section>
					<h2>Fixing your code</h2>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>End user cache</h2>
					<ul>
						<li>Learn HTTP and it's caching mechanisms</li>
						<li>Long max-age</li>
						<li>Change url when changes occur.</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>web.config</h3>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>CDN</h2>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Minimize and bundle js</h2>
					<ul>
						<li>Easier on the client and the server</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Internal cache</h3>
					<ul>
						<li>Memchached and redis</li>
						<li>Layer 7 load balancing</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Choosing databases</h3>
					<ul>
						<li>NoSQL has happened for a reason</li>
						<li>Different databases have differnet sweet spots</li>
						<li>Mix and match in the same application</li>
						<li>Choose database based on usage, not old habits</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Sharding</h3>
					<ul>
						<li></li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Understand your databases</h3>
					<ul>
						<li>Don't hide all the database features behind a generic repository</li>
						<li>Don't be afraid to batch data on the datbases terms</li>
						<li>Use your database's strengths and be aware of it's weaknesses</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Save your data based on usage</h3>
					<ul>
						<li>In read heavy use cases, make it cheap to read.</li>
						<li>In write heavy use cases, make it cheap to write</li>
						<li>Mix and match architectures in your application</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Batch your network queries</h3>
					<ul>
						<li>Don't pretend memory calls and network calls are the same</li>
						<li>Separate request based on caching </li>
						<li>Leverage HTTP cache inside your application aswell. .NET default behaviour is bypassing cache.</li>
					</ul>
					<aside class="notes">
						Remember .NET uses IE's caching, so upgrade IE for better caching.
					</aside>
				</section>
				<section>
					<h3>Put state on the client</h3>
					<ul>
						<li>Avoid sticky sessions</li>
						<li>No memory used per user</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Reduce the number of requests</h3>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Do slow work in the background</h3>
					<ul>
						<li>Not all processes have the same priority</li>
						<li>Synchronicity actions can be faked in the UI layer</li>
						<li>Handles sudden bursts in traffic better</li>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>Reject features</h3>
					<ul>
						<li>Avoid cross cutting features if you can</li>
						<li>Product owners don't understand how features kill performance. Tell them.</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h3>TL;DR</h3>
					<ul>
						<li>Move fast</li>
						<li>Measure</li>
						<li>Don't stop thinking about speed</li>
					</ul>
					<aside class="notes">
					</aside>
				</section>
			</div>
		</div>
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>
		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
		</script>
	</body>
</html>
